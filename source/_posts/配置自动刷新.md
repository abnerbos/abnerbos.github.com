---
title: 配置热更新
date: 2019-03-12 15:21:37
tags: [Zookeeper, Spring Boot, Spring cloud]
categories: code
---

> Any time you need a switch that works immediately

## 前言

很早之前，就想把项目中用到的`配置热更新`同步到博客中，嚷嚷着等空了就把文章给补上，还担心自己忘记了，在之前的文章中加上了TODO。最终还是无济于事，拖到了今天，拖到了一段旅程要结束的时候。

## View
大体的方案流程是依托于Zookeeper进行配置管理，监听配置变更，自动执行项目中Environment properties、@ConfigurationProperties和@Value 配置更新，达到不重启工程，配置实时更新的目的。

![](https://i.loli.net/2019/03/13/5c88e28846713.jpg)

<!-- more -->

Zookeeper watcher的过程按下不表，Environment properties也是覆盖即可，着重讨论下如何进行bean热更新

### 第一版
最初的设想是，手动从Context中获取所有需要更新的bean，@ConfigurationProperties 类可以通过注解进行获取，但@Value放在Field上，需要特殊处理。要么直接扫描容器中的所有bean，要么增加注解进行标记。考虑到毕竟只有少部分的bean需要进行更新，采取后者，增加@YqgZookeeperPropertyWatcher统一标注需要热更新的bean。
- 获取所有@YqgZookeeperPropertyWatcher 标注的bean
- 由于代理的存在，需要获取到目标对象
- @ConfigurationProperties 配置需要手动拼接 prefix 和 fileldName，fileldName采取通用的驼峰转中划线方式
- 使用 environment.resolveRequiredPlaceholders 通过产生的key获取配置的属性信息
- 通过反射将获取到的属性信息写回去，只处理了常用的基本类型

部分代码如下：

```Java
public void nodeChanged() throws Exception {
  Map<String, Object> configMap = YqgZookeeperDataParser.getPrefixData(nodeCache.getCurrentData().getData(), prefix);
  environment.getPropertySources().addAfter(RandomValuePropertySource.RANDOM_PROPERTY_SOURCE_NAME, new MapPropertySource(ZOOKEEPER_PROPERTY_SOURCE, configMap));
  Map<String, Object> beanMap = applicationContext.getBeansWithAnnotation(YqgZookeeperPropertyWatcher.class);   
  for (Object object : beanMap.values()) {
    Object bean = getTarget(object);    
    Class clazz = bean.getClass();    
    ConfigurationProperties configAnnotation = (ConfigurationProperties) clazz.getAnnotation(ConfigurationProperties.class); 
  for (Field field : FieldUtils.getAllFieldsList(clazz)) {
      Value valueAnnotation = field.getAnnotation(Value.class);    
      String data = null;
      if (null != valueAnnotation) {
        try {
          data = environment.resolveRequiredPlaceholders(valueAnnotation.value());
          } catch (IllegalArgumentException ex) {
          log.warn("占位符解析失败, bean:{} 属性:{}注解为:{}", bean, field.getName(), valueAnnotation.value());
        }
      } else if (null != configAnnotation) {
        data = environment.getProperty(configAnnotation.prefix() + "." + getFieldConfigName(field));
      }
      if (null == data) {
        continue;
      }
      setFieldData(bean, field, data);
    }
  }
}

private void setFieldData(Object bean, Field field, Object data) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
  log.info("监听zk信息， 更新bean:{} 属性:{} 为:{}", bean, field.getName(), data);
  String typeName = field.getGenericType().getTypeName();
  field.setAccessible(true);   
  switch (typeName) {
    case "java.lang.String":
      field.set(bean, data.toString());
      break; 
    case "java.lang.Boolean":
    case "boolean":
      field.setBoolean(bean, Boolean.valueOf(data.toString()));
      break; 
    case "java.lang.Integer":
    case "int":
      field.setInt(bean, Integer.parseInt(data.toString()));
      break; 
    default:
      log.warn("暂不支持类型:{}", typeName);
  }
}
  private String getSetMethodName(Field field) {
    return "set" + field.getName().substring(0, 1).toUpperCase() + field.getName().substring(1);
  }
  private String getFieldConfigName(Field field) {
    StringBuilder sb = new StringBuilder();
    for (char c : field.getName().toCharArray()) {
      if (CharUtils.isAsciiAlphaUpper(c)) {
        sb.append('-').append(Character.toLowerCase(c));
        } else {
        sb.append(c);
        }
      }
      return sb.toString();
    }
  }

private static Object getTarget(Object object) throws Exception {
  if (!AopUtils.isAopProxy(object)) {
    return object;
  }
  if (AopUtils.isJdkDynamicProxy(object)) {
    return getJdkDynamicProxyTargetObject(object);
  } else {
  return getCglibProxyTargetObject(object);
  }
}

private static Object getCglibProxyTargetObject(Object proxy) throws Exception {
  Field h = proxy.getClass().getDeclaredField("CGLIB$CALLBACK_0");
  h.setAccessible(true);
  Object dynamicAdvisedInterceptor = h.get(proxy);
  Field advised = dynamicAdvisedInterceptor.getClass().getDeclaredField("advised");
  advised.setAccessible(true);
  return ((AdvisedSupport) advised.get(dynamicAdvisedInterceptor)).getTargetSource().getTarget(); 
 }

private static Object getJdkDynamicProxyTargetObject(Object proxy) throws Exception {
  Field h = proxy.getClass().getSuperclass().getDeclaredField("h");
  h.setAccessible(true);
  AopProxy aopProxy = (AopProxy) h.get(proxy);
  Field advised = aopProxy.getClass().getDeclaredField("advised");
  advised.setAccessible(true);
  return ((AdvisedSupport) advised.get(aopProxy)).getTargetSource().getTarget(); 
 }

```


### 第二版
第一版中bean都是手动反射进行更新，处理的也只是简单基本类型，并且@ConfigurationProperties 也不支持嵌套，@Value如果有spel表达式的话无法更新，只能满足基本日常使用了，这版代码在线上跑了小半年。

- 解决@ConfigurationProperties无法处理嵌套类型，使用Spring Boot自带的EnvironmentChangeEvent事件进行更新
- @Value在处理过程中，过滤掉SPEL表达式，使用更友好的 environment.getConversionService() 进行类型转换和FieldUtils.writeField 数据设置
- 由于公司所有项目的配置放在ZK同一个节点上，其他项目配置的变动也会触发watcher，每次进行前置diff，无改动不更新
- 由于数据库等加密配置的存在，远端的配置必定和容器的数据不等，不想处理解密过程，手动过滤掉加密配置信息

调整了大部分逻辑：
```Java
public void nodeChanged() throws Exception {
  Map<String, Object> currentDataMap = obtainZookeeperPropertyData();
  Map<String, Object> configDataMap = YqgZookeeperDataParser.getPrefixData(nodeCache.getCurrentData().getData(), prefix);
  fillEncryptConfig(currentDataMap, configDataMap);
  Set<String> keys = changes(currentDataMap, configDataMap).keySet();
  if (CollectionUtils.isEmpty(keys)) {
    return;
  }
  currentDataMap.putAll(configDataMap);
  environment.getPropertySources().addAfter(RandomValuePropertySource.RANDOM_PROPERTY_SOURCE_NAME, new MapPropertySource(ZOOKEEPER_PROPERTY_SOURCE, currentDataMap));
  doRefreshValue();
  doRefreshConfigurationProperties(keys); 
}
private void doRefreshValue() throws Exception {
  Map<String, Object> beanMap = applicationContext.getBeansWithAnnotation(YqgZookeeperPropertyWatcher.class);   
  for (Object object : beanMap.values()) {
    Object bean = getTarget(object);
    Class clazz = bean.getClass();
    for (Field field : FieldUtils.getAllFieldsList(clazz)) {
      Value valueAnnotation = field.getAnnotation(Value.class);   if (null != valueAnnotation) {
        if (isSpelExpression(valueAnnotation.value())) {
          continue;
        }
        try {
          String property = environment.resolveRequiredPlaceholders(valueAnnotation.value());
          Object data = environment.getConversionService().convert(property, field.getType());
          FieldUtils.writeField(field, object, data, true);
          log.info("监听zk信息， 更新bean:{} 属性:{} 为:{}", bean, field.getName(), data);
        } catch (IllegalArgumentException ex) {
          log.warn("占位符解析失败, bean:{} 属性:{}注解为:{}", bean, field.getName(), valueAnnotation.value());
        }
      }
    }
  }
}

private void doRefreshConfigurationProperties(Set<String> keys) {
  log.info("发布事件EnvironmentChangeEvent，涉及配置为:{}", keys);
  applicationContext.publishEvent(new EnvironmentChangeEvent(keys)); }

private boolean isSpelExpression(String expression) {
  return StringUtils.isNotBlank(expression) && expression.startsWith("#{") && expression.endsWith("}"); }

private boolean isJasyptEncrypt(String property){
  return StringUtils.isNotBlank(property) && property.startsWith("ENC(") && property.endsWith(")"); }

private Map<String, Object> obtainZookeeperPropertyData() {
  PropertySource<?> propertySource = environment.getPropertySources().get(ZOOKEEPER_PROPERTY_SOURCE);
  Map<String, Object> dataMap = new HashMap<>();
  extract(propertySource, dataMap);
  return dataMap;   
 }

private void extract(PropertySource<?> parent, Map<String, Object> result) {
  if (parent instanceof CompositePropertySource) {
    try {
      List<PropertySource<?>> sources = new ArrayList<PropertySource<?>>();
      for (PropertySource<?> source : ((CompositePropertySource) parent).getPropertySources()) {
        sources.add(0, source);
      }
      for (PropertySource<?> source : sources) {
        extract(source, result);
      }
    } catch (Exception e) {
      return;
    }
  } else if (parent instanceof EnumerablePropertySource) {
    for (String key : ((EnumerablePropertySource<?>) parent).getPropertyNames()) {
      result.put(key, parent.getProperty(key));
    }
  }
}

private Map<String, Object> changes(Map<String, Object> before,
  Map<String, Object> after) {
  Map<String, Object> result = new HashMap<>();
  for (String key : before.keySet()) {
    if (!after.containsKey(key)) {
      result.put(key, null);
  } else if (!equal(before.get(key), after.get(key))) {
      result.put(key, after.get(key));
      }
    }
  for (String key : after.keySet()) {
    if (!before.containsKey(key)) {
      result.put(key, after.get(key));
      }
    }
    return result; 
  }

private void fillEncryptConfig(Map<String, Object> before, Map<String, Object> after) {
  Iterator<String> iterator = after.keySet().iterator();
  while (iterator.hasNext()) {
    String key = iterator.next();
  if (isJasyptEncrypt(after.get(key).toString())) {
      if (before.containsKey(key)) {
        after.put(key, before.get(key));
   } else {
        iterator.remove();
        }
      }
    }
  }
```


### 第三版
其实第二版，已经能非常友好的处理热更新了，线上响应正常，使用上也非常透明，唯一还遗留的就是@Value 处理太粗暴，SPEL表达式仍不支持，加之最近想整理这篇文档，再次查阅了相关文档。比较大的收获是Spring Cloud已经囊括了以上的热更新，在Spring Cloud Config中可使用git作为配置配置源，调用EndPoint进行刷新。其实一年前，看过相关内容，但没想好怎么和ZK进行合并。所以，准备再更新一般，使用Spring的实现再次简化逻辑。

核心代码在于使用scope进行更新，简化原有的@Value更新逻辑
```Java
private void doRefreshValue() throws Exception {
  scope.refreshAll(); 
}
```


Spring Cloud 热更新逻辑可参考： http://www.scienjus.com/spring-cloud-refresh/

文章最末提到：
> 在使用 Eureka 的项目中要谨慎的使用热更新，过于频繁的更新可能会使大量项目频繁的标记下线和上线，需要注意

查看了github 上相关 issue : https://github.com/spring-cloud/spring-cloud-netflix/issues/1857 ,可以通过升级版本来解决，本地实践了下，发现升级后代码并未变化，`EurekaDiscoveryClientConfiguration` 还是会进行下线并上线的操作，具体启动工程观察日志也确实是这样，这个问题可能得留到后面上线再持续进行观察。

## 总结
用Java的好处，在于你需要的大部分功能，框架都能帮你提供，或早或晚，虽然遗憾没能早点借用Spring Cloud的实现，简化逻辑的同时提高代码可读性，但终究是这一步步走来，才加深了自己的理解，提升自己对框架的把握。







